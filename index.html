<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quiniela NFL Playoffs 2026 — Bracket</title>
  <style>
    :root { --bd:#e5e7eb; --bg:#fafafa; --tx:#111827; --mut:#6b7280; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; color:var(--tx); background:var(--bg); }
    .wrap { max-width: 1050px; margin: 24px auto; padding: 0 14px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; padding: 12px 0 6px; }
    h1 { font-size: 18px; margin:0; }
    .muted { color: var(--mut); }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .card { background:white; border:1px solid var(--bd); border-radius:14px; padding:14px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    .card h2 { margin:0 0 10px; font-size: 16px; }
    .card h3 { margin:0 0 10px; font-size: 14px; }
    .card p { margin: 8px 0; }
    input, select, button { font: inherit; }
    input, select { padding: 9px 10px; border-radius:10px; border:1px solid var(--bd); width: 100%; }
    button { padding: 9px 12px; border-radius:10px; border:1px solid var(--bd); background:#111827; color:white; cursor:pointer; }
    button.secondary { background:white; color:#111827; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .nav { display:flex; gap:8px; flex-wrap:wrap; padding: 10px 0 16px; }
    .nav button { background:white; color:#111827; }
    .nav button.active { background:#111827; color:white; }
    .grid { display:grid; gap:12px; }
    @media (min-width: 980px) {
      .grid.cols-2 { grid-template-columns: 1fr 1fr; }
      .grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
    }
    .small { font-size: 12px; }
    .pill { display:inline-flex; align-items:center; gap:6px; padding: 4px 10px; border-radius:999px; border:1px solid var(--bd); background:white; font-size:12px; }
    .pill.ok { border-color:#bbf7d0; background:#f0fdf4; color:#166534; }
    .pill.bad { border-color:#fecaca; background:#fef2f2; color:#991b1b; }
    .match { border:1px solid var(--bd); border-radius:12px; padding:10px; background:white; }
    .match .top { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .match .teams { display:grid; gap:8px; margin-top:10px; }
    .teamBtn { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px; border-radius:12px; border:1px solid var(--bd); background:white; cursor:pointer; text-align:left; }
    .teamBtn strong { font-size: 13px; }
    .teamBtn span { font-size: 12px; color: var(--mut); }
    .teamBtn.selected { border-color:#93c5fd; background:#eff6ff; }
    .teamBtn:disabled { opacity:.6; cursor:not-allowed; }
    .colsBracket { display:grid; gap:12px; }
    @media (min-width: 980px) {
      .colsBracket { grid-template-columns: 1fr 1fr 1fr 1fr; }
    }
    .toast { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background: #111827; color: white; padding: 10px 12px; border-radius: 12px; display:none; max-width: 92vw; }
    a { color: inherit; }
    .divider { height:1px; background: var(--bd); margin: 10px 0; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Quiniela NFL Playoffs 2026 — Bracket</h1>
        <div class="muted small">Un solo archivo HTML + Supabase (Auth/DB/RLS). Bracket con reseeding real.</div>
      </div>
      <div id="userBox" class="row" style="align-items:center; justify-content:flex-end;"></div>
    </header>

    <div id="app"></div>
  </div>

  <div id="toast" class="toast"></div>

  <!-- Supabase JS (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    /***********************************************************************
     * CONFIG — REEMPLAZA ESTO
     **********************************************************************/
    const SUPABASE_URL = "https://TU-PROYECTO.supabase.co";
    const SUPABASE_ANON_KEY = "TU_ANON_KEY";

    // Temporada objetivo
    const SEASON = 2026;

    /***********************************************************************
     * DB expected tables (mínimo):
     * - pools(id, name, season, admin_user_id, created_at)
     * - teams(id, season, conference, abbrev, name)
     * - seeds(id, season, conference, seed, team_id)
     * - entries(id, pool_id, user_id, display_name, created_at)
     * - games(id, season, conference, round, game_no, kickoff_at, home_seed, away_seed)
     * - picks(id, entry_id, game_id, winner_team_id)
     *
     * RLS recomendado: bloquear writes a picks cuando now() >= kickoff_at.
     **********************************************************************/

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const $ = (sel) => document.querySelector(sel);
    const el = (tag, attrs={}, children=[]) => {
      const n = document.createElement(tag);
      for (const [k,v] of Object.entries(attrs)) {
        if (k === "class") n.className = v;
        else if (k === "html") n.innerHTML = v;
        else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2).toLowerCase(), v);
        else n.setAttribute(k, v);
      }
      (Array.isArray(children) ? children : [children]).forEach(c => {
        if (c == null) return;
        if (typeof c === "string") n.appendChild(document.createTextNode(c));
        else n.appendChild(c);
      });
      return n;
    };

    function toast(msg) {
      const t = $("#toast");
      t.textContent = msg;
      t.style.display = "block";
      clearTimeout(toast._to);
      toast._to = setTimeout(() => t.style.display = "none", 3200);
    }

    function fmtDate(ts) {
      try { return new Date(ts).toLocaleString("es-MX"); } catch { return String(ts); }
    }

    function isLocked(kickoffAt) {
      return new Date(kickoffAt).getTime() <= Date.now();
    }

    async function getUser() {
      const { data } = await supabase.auth.getUser();
      return data.user || null;
    }

    /***********************************************************************
     * STATE
     **********************************************************************/
    const state = {
      user: null,
      view: "pools", // pools | play | admin
      pools: [],
      currentPool: null,
      entry: null,
      seeds: null,         // { AFC: {1: teamObj, ...}, NFC: {...} }
      games: [],           // list
      picksByGame: {},     // { gameId: teamId }
      teamsById: {},       // teamId -> teamObj
    };

    /***********************************************************************
     * LOADERS
     **********************************************************************/
    async function loadPools() {
      const { data, error } = await supabase
        .from("pools")
        .select("*")
        .eq("season", SEASON)
        .order("created_at", { ascending: false });

      if (error) throw error;
      state.pools = data || [];
    }

    async function loadSeedsAndTeams() {
      const { data: teams, error: tErr } = await supabase
        .from("teams")
        .select("*")
        .eq("season", SEASON);

      if (tErr) throw tErr;

      state.teamsById = {};
      for (const t of teams || []) state.teamsById[t.id] = t;

      const { data: seeds, error: sErr } = await supabase
        .from("seeds")
        .select("conference, seed, team_id")
        .eq("season", SEASON);

      if (sErr) throw sErr;

      const map = { AFC: {}, NFC: {} };
      for (const r of seeds || []) {
        map[r.conference][r.seed] = state.teamsById[r.team_id];
      }
      state.seeds = map;
    }

    async function loadGames() {
      const { data, error } = await supabase
        .from("games")
        .select("*")
        .eq("season", SEASON)
        .order("round", { ascending: true })
        .order("conference", { ascending: true })
        .order("game_no", { ascending: true });

      if (error) throw error;
      state.games = data || [];
    }

    async function loadEntry(poolId) {
      const user = await getUser();
      if (!user) return;

      const { data, error } = await supabase
        .from("entries")
        .select("*")
        .eq("pool_id", poolId)
        .eq("user_id", user.id)
        .maybeSingle();

      if (error) throw error;
      state.entry = data || null;
    }

    async function loadPicks(entryId) {
      if (!entryId) { state.picksByGame = {}; return; }

      const { data, error } = await supabase
        .from("picks")
        .select("game_id, winner_team_id")
        .eq("entry_id", entryId);

      if (error) throw error;

      const map = {};
      for (const p of data || []) map[p.game_id] = p.winner_team_id;
      state.picksByGame = map;
    }

    /***********************************************************************
     * BRACKET LOGIC (NFL reseeding)
     **********************************************************************/

    // Helper: get WC games for a conf: by seeds 2v7,3v6,4v5 (stored in games table)
    function wcGames(conf) {
      return state.games.filter(g => g.round === "WC" && g.conference === conf)
        .sort((a,b) => a.game_no - b.game_no);
    }

    function divGames(conf) {
      return state.games.filter(g => g.round === "DIV" && g.conference === conf)
        .sort((a,b) => a.game_no - b.game_no);
    }

    function confGame(conf) {
      return state.games.find(g => g.round === "CONF" && g.conference === conf) || null;
    }

    function sbGame() {
      return state.games.find(g => g.round === "SB") || null;
    }

    function seedTeam(conf, seedNum) {
      return state.seeds?.[conf]?.[seedNum] || null;
    }

    // WC matchup teams from seeds (fixed)
    function wcMatchTeams(game) {
      const home = seedTeam(game.conference, game.home_seed);
      const away = seedTeam(game.conference, game.away_seed);
      return { home, away };
    }

    // Get WC winners as array of { seed, team }
    function wcWinners(conf) {
      const games = wcGames(conf);
      const winners = [];
      for (const g of games) {
        const winnerTeamId = state.picksByGame[g.id];
        if (!winnerTeamId) continue;
        const team = state.teamsById[winnerTeamId];
        // find seed for that team (from seeds map)
        let foundSeed = null;
        for (const [s, t] of Object.entries(state.seeds?.[conf] || {})) {
          if (t && t.id === winnerTeamId) { foundSeed = Number(s); break; }
        }
        if (foundSeed != null) winners.push({ seed: foundSeed, team });
      }
      return winners;
    }

    // Compute Divisional matchups based on winners (reseeding):
    // Remaining teams: seed 1, seed 2, and 3 WC winners.
    // Lowest remaining seed number is "best" (1), highest number is "worst".
    // #1 plays the WORST seed (highest number) among remaining (seed2 + WC winners)
    // #2 plays the remaining WORST among remaining two WC winners.
    function computeDivisionalMatchups(conf) {
      const winners = wcWinners(conf);
      if (winners.length < 3) return null;

      const one = { seed: 1, team: seedTeam(conf, 1) };
      const two = { seed: 2, team: seedTeam(conf, 2) };

      const remaining = [two, ...winners]; // candidates for seed1 opponent include seed2 + WC winners
      // worst seed = highest seed number
      remaining.sort((a,b) => b.seed - a.seed);
      const opp1 = remaining[0];

      // others (excluding opp1) are for seed2's game: pick worst among them
      const rest = remaining.slice(1);
      rest.sort((a,b) => b.seed - a.seed);
      const opp2 = rest[0];

      // last team is the leftover (from rest)
      const leftover = rest[1];

      return [
        { matchupNo: 1, home: one, away: opp1 },              // seed 1 home
        { matchupNo: 2, home: two, away: opp2 || leftover }   // seed 2 home
      ];
    }

    // Conference matchups: winners of two divisional games
    function divisionalWinners(conf) {
      const games = divGames(conf);
      // We'll use actual DIV game records to store picks; but matchups are computed
      const winners = [];
      for (const g of games) {
        const winnerId = state.picksByGame[g.id];
        if (!winnerId) continue;
        winners.push(state.teamsById[winnerId]);
      }
      return winners;
    }

    function conferenceWinner(conf) {
      const g = confGame(conf);
      if (!g) return null;
      const winnerId = state.picksByGame[g.id];
      return winnerId ? state.teamsById[winnerId] : null;
    }

    /***********************************************************************
     * WRITE OPS
     **********************************************************************/
    async function upsertPick(gameId, teamId) {
      if (!state.entry) throw new Error("No entry");
      const existing = state.picksByGame[gameId] || null;

      // Optimistic UI
      state.picksByGame[gameId] = teamId;
      render();

      const { error } = await supabase
        .from("picks")
        .upsert([{ entry_id: state.entry.id, game_id: gameId, winner_team_id: teamId }], { onConflict: "entry_id,game_id" });

      if (error) {
        // rollback
        if (existing) state.picksByGame[gameId] = existing;
        else delete state.picksByGame[gameId];
        render();
        throw error;
      }

      // optional audit insert
      await supabase.from("pick_audit").insert([{
        entry_id: state.entry.id,
        game_id: gameId,
        old_team_id: existing,
        new_team_id: teamId,
        changed_by: state.user.id
      }]).catch(() => { /* ignore if audit not present or RLS blocks */ });

      toast("Pick guardado.");
    }

    // When a lower-round pick changes, clear downstream picks to keep bracket consistent
    async function clearDownstream(conf, fromRound) {
      if (!state.entry) return;

      const roundOrder = { WC: 1, DIV: 2, CONF: 3, SB: 4 };
      const min = roundOrder[fromRound] + 1;

      const toDeleteIds = state.games
        .filter(g => roundOrder[g.round] >= min)
        .filter(g => g.round === "SB" || g.conference === conf)
        .map(g => g.id);

      if (!toDeleteIds.length) return;

      // Update local
      for (const gid of toDeleteIds) delete state.picksByGame[gid];
      render();

      const { error } = await supabase
        .from("picks")
        .delete()
        .eq("entry_id", state.entry.id)
        .in("game_id", toDeleteIds);

      if (error) {
        // if delete fails, reload picks from server to sync
        await loadPicks(state.entry.id);
        render();
        throw error;
      }
    }

    /***********************************************************************
     * UI
     **********************************************************************/
    function renderUserBox() {
      const box = $("#userBox");
      box.innerHTML = "";

      if (!state.user) return;

      box.appendChild(el("span", { class:"pill ok" }, `Conectado: ${state.user.email}`));
      box.appendChild(el("button", {
        class: "secondary",
        onclick: async () => { await supabase.auth.signOut(); }
      }, "Salir"));
    }

    function nav() {
      return el("div", { class:"nav" }, [
        el("button", { class: state.view==="pools" ? "active": "", onclick: () => { state.view="pools"; render(); } }, "Pools"),
        state.currentPool ? el("button", { class: state.view==="play" ? "active": "", onclick: () => { state.view="play"; render(); } }, "Mi bracket") : null,
        state.currentPool ? el("button", { class: state.view==="admin" ? "active": "", onclick: () => { state.view="admin"; render(); } }, "Admin") : null,
      ]);
    }

    function loginView() {
      let sent = false;
      const emailInput = el("input", { placeholder:"tu@email.com", type:"email" });
      const sendBtn = el("button", { onclick: async () => {
        const email = emailInput.value.trim();
        if (!email) return toast("Escribe tu email.");
        const { error } = await supabase.auth.signInWithOtp({ email });
        if (error) return toast(error.message);
        sent = true;
        render();
      } }, "Enviar link de acceso");

      const wrap = el("div", { class:"card", style:"max-width:460px;margin: 40px auto;" }, [
        el("h2", {}, "Inicia sesión"),
        el("p", { class:"muted" }, "Te enviamos un link por correo (OTP)."),
        emailInput,
        el("div", { style:"height:10px" }),
        sendBtn,
        sent ? el("p", { class:"small muted" }, "Listo. Revisa tu correo (incluye spam/promociones).") : null,
        el("div", { class:"divider" }),
        el("p", { class:"small muted" },
          "Nota: la anti-trampa real depende de RLS en Supabase. El frontend solo muestra/oculta controles.")
      ]);
      return wrap;
    }

    function poolsView() {
      const poolList = el("div", { class:"card" }, [
        el("h2", {}, "Pools (Playoffs NFL 2026)"),
        el("p", { class:"muted small" }, "Abre un pool para crear tu entrada y llenar el bracket."),
        ...state.pools.map(p => el("div", { class:"match" }, [
          el("div", { class:"top" }, [
            el("div", {}, [
              el("div", {}, el("strong", {}, p.name)),
              el("div", { class:"small muted" }, `Temporada: ${p.season} · Creado: ${fmtDate(p.created_at)}`)
            ]),
            el("button", { class:"secondary", onclick: async () => { await openPool(p.id); } }, "Abrir")
          ])
        ]))
      ]);

      const createName = el("input", { placeholder:"Nombre del pool (ej: Quiniela amigos)" });
      const createBtn = el("button", { onclick: async () => {
        const name = createName.value.trim();
        if (!name) return toast("Ponle un nombre.");
        const { error } = await supabase
          .from("pools")
          .insert([{ name, season: SEASON, admin_user_id: state.user.id }]);
        if (error) return toast(error.message);
        toast("Pool creado.");
        await loadPools();
        render();
      } }, "Crear pool (serás admin)");

      const createCard = el("div", { class:"card" }, [
        el("h2", {}, "Crear pool"),
        el("p", { class:"muted small" }, "El admin deberá cargar seeds y juegos (kickoff_at) en la sección Admin."),
        createName,
        el("div", { style:"height:10px" }),
        createBtn
      ]);

      return el("div", { class:"grid cols-2" }, [poolList, createCard]);
    }

    function adminView() {
      if (!state.currentPool) return el("div", { class:"card" }, "No hay pool abierto.");
      const isAdmin = (state.currentPool.admin_user_id === state.user.id);

      const base = el("div", { class:"card" }, [
        el("h2", {}, "Admin"),
        el("p", {}, [
          el("span", {}, "Pool: "),
          el("strong", {}, state.currentPool.name),
          el("span", { class:"muted small" }, ` · id: ${state.currentPool.id}`)
        ]),
        !isAdmin ? el("p", { class:"pill bad" }, "No eres admin de este pool.") : el("p", { class:"pill ok" }, "Eres admin.")
      ]);

      if (!isAdmin) return base;

      const note = el("div", { class:"card" }, [
        el("h2", {}, "Qué debes cargar (una sola vez)"),
        el("p", { class:"muted small" }, "Para que el bracket funcione, en Supabase debes tener:"),
        el("ul", {}, [
          el("li", {}, "teams (AFC/NFC)"),
          el("li", {}, "seeds: 1..7 por conferencia"),
          el("li", {}, "games: WC(3 por conf), DIV(2 por conf), CONF(1 por conf), SB(1) con kickoff_at"),
          el("li", {}, "RLS: bloquear cambios cuando now() >= kickoff_at (anti-trampa real)")
        ]),
        el("p", { class:"muted small" }, "Este HTML no incluye formularios largos de administración para seeds/juegos porque suelen cargarse más fácil vía SQL/CSV. Si quieres, te hago una versión con panel admin completo (también en un solo HTML).")
      ]);

      const gamesCard = el("div", { class:"card" }, [
        el("h2", {}, "Juegos detectados"),
        el("p", { class:"muted small" }, "Verifica que existan los 13 juegos: WC(6) + DIV(4) + CONF(2) + SB(1)."),
        el("div", { class:"small" }, state.games.length
          ? el("ul", {}, state.games.map(g => el("li", {}, `${g.round} ${g.conference||""} #${g.game_no} · kickoff: ${fmtDate(g.kickoff_at)} · home_seed:${g.home_seed||"-"} away_seed:${g.away_seed||"-"}`)))
          : el("div", { class:"pill bad" }, "No hay juegos cargados para esta temporada.")
        )
      ]);

      return el("div", { class:"grid cols-2" }, [base, note, gamesCard]);
    }

    function entryCard() {
      const card = el("div", { class:"card" }, [
        el("h2", {}, "Mi entrada"),
        el("p", { class:"muted small" }, "Crea tu entrada para poder guardar picks.")
      ]);

      if (!state.entry) {
        const nameInput = el("input", { placeholder:"Nombre visible (ej: Miguel)" });
        const btn = el("button", { onclick: async () => {
          const display_name = (nameInput.value.trim() || "Participante");
          const { data, error } = await supabase
            .from("entries")
            .insert([{ pool_id: state.currentPool.id, user_id: state.user.id, display_name }])
            .select("*")
            .single();
          if (error) return toast(error.message);
          state.entry = data;
          await loadPicks(state.entry.id);
          toast("Entrada creada.");
          render();
        } }, "Crear mi entrada");
        card.appendChild(nameInput);
        card.appendChild(el("div", { style:"height:10px" }));
        card.appendChild(btn);
      } else {
        const nameInput = el("input", { value: state.entry.display_name });
        const saveBtn = el("button", { class:"secondary", onclick: async () => {
          const display_name = nameInput.value.trim() || "Participante";
          const { error } = await supabase
            .from("entries")
            .update({ display_name })
            .eq("id", state.entry.id);
          if (error) return toast(error.message);
          state.entry.display_name = display_name;
          toast("Nombre actualizado.");
        } }, "Guardar nombre");
        card.appendChild(el("div", { class:"small muted" }, `ID: ${state.entry.id}`));
        card.appendChild(el("div", { style:"height:10px" }));
        card.appendChild(nameInput);
        card.appendChild(el("div", { style:"height:10px" }));
        card.appendChild(saveBtn);
      }

      return card;
    }

    function matchCard({ title, kickoffAt, teamA, teamB, selectedTeamId, onPick, locked }) {
      const lockPill = locked
        ? el("span", { class:"pill bad" }, "CERRADO")
        : el("span", { class:"pill ok" }, "ABIERTO");

      const top = el("div", { class:"top" }, [
        el("div", {}, [
          el("div", {}, el("strong", {}, title)),
          el("div", { class:"small muted" }, `Kickoff: ${fmtDate(kickoffAt)}`)
        ]),
        lockPill
      ]);

      const btnA = el("button", {
        class: "teamBtn" + (selectedTeamId === teamA?.id ? " selected" : ""),
        disabled: locked || !teamA,
        onclick: async () => onPick(teamA)
      }, [
        el("div", {}, [
          el("strong", {}, teamA ? `${teamA.abbrev}` : "—"),
          el("div", {}, el("span", {}, teamA ? teamA.name : "Sin definir"))
        ]),
        el("span", {}, selectedTeamId === teamA?.id ? "✔" : "")
      ]);

      const btnB = el("button", {
        class: "teamBtn" + (selectedTeamId === teamB?.id ? " selected" : ""),
        disabled: locked || !teamB,
        onclick: async () => onPick(teamB)
      }, [
        el("div", {}, [
          el("strong", {}, teamB ? `${teamB.abbrev}` : "—"),
          el("div", {}, el("span", {}, teamB ? teamB.name : "Sin definir"))
        ]),
        el("span", {}, selectedTeamId === teamB?.id ? "✔" : "")
      ]);

      return el("div", { class:"match" }, [
        top,
        el("div", { class:"teams" }, [btnA, btnB])
      ]);
    }

    function bracketColumn(conf, round) {
      // round: WC | DIV | CONF
      const col = el("div", { class:"card" }, [
        el("h2", {}, `${conf} — ${round === "WC" ? "Wild Card" : round === "DIV" ? "Divisional" : "Conference"}`),
      ]);

      const games = round === "WC" ? wcGames(conf)
        : round === "DIV" ? divGames(conf)
        : round === "CONF" ? (confGame(conf) ? [confGame(conf)] : [])
        : [];

      if (!games.length) {
        col.appendChild(el("p", { class:"pill bad" }, "No hay juegos cargados para esta ronda."));
        return col;
      }

      // Build matchups
      if (round === "WC") {
        for (const g of games) {
          const { home, away } = wcMatchTeams(g);
          const locked = isLocked(g.kickoff_at);
          col.appendChild(matchCard({
            title: `WC #${g.game_no} (${g.home_seed} vs ${g.away_seed})`,
            kickoffAt: g.kickoff_at,
            teamA: home,
            teamB: away,
            selectedTeamId: state.picksByGame[g.id] || null,
            locked,
            onPick: async (team) => {
              if (!state.entry) return toast("Primero crea tu entrada.");
              // Changing WC affects downstream
              const prev = state.picksByGame[g.id] || null;
              try {
                if (prev && prev !== team.id) await clearDownstream(conf, "WC");
                await upsertPick(g.id, team.id);
              } catch (e) {
                toast(e.message || "Error guardando pick");
              }
            }
          }));
        }
      }

      if (round === "DIV") {
        const matchups = computeDivisionalMatchups(conf);
        if (!matchups) {
          col.appendChild(el("p", { class:"muted small" }, "Primero elige ganadores de los 3 juegos de Wild Card para calcular reseeding."));
          return col;
        }

        // We have 2 DIV games stored; we map matchup 1->game_no 1, matchup 2->game_no 2
        for (const g of games) {
          const mu = matchups.find(m => m.matchupNo === g.game_no);
          const locked = isLocked(g.kickoff_at);
          col.appendChild(matchCard({
            title: `DIV #${g.game_no} (reseeding)`,
            kickoffAt: g.kickoff_at,
            teamA: mu?.home?.team || null,
            teamB: mu?.away?.team || null,
            selectedTeamId: state.picksByGame[g.id] || null,
            locked,
            onPick: async (team) => {
              if (!state.entry) return toast("Primero crea tu entrada.");
              const prev = state.picksByGame[g.id] || null;
              try {
                if (prev && prev !== team.id) await clearDownstream(conf, "DIV");
                await upsertPick(g.id, team.id);
              } catch (e) {
                toast(e.message || "Error guardando pick");
              }
            }
          }));
        }
      }

      if (round === "CONF") {
        const g = games[0];
        const locked = isLocked(g.kickoff_at);
        const divW = divisionalWinners(conf);
        if (divW.length < 2) {
          col.appendChild(el("p", { class:"muted small" }, "Primero elige ganadores de Divisional para definir este juego."));
          return col;
        }

        col.appendChild(matchCard({
          title: `CONF (${conf})`,
          kickoffAt: g.kickoff_at,
          teamA: divW[0],
          teamB: divW[1],
          selectedTeamId: state.picksByGame[g.id] || null,
          locked,
          onPick: async (team) => {
            if (!state.entry) return toast("Primero crea tu entrada.");
            const prev = state.picksByGame[g.id] || null;
            try {
              if (prev && prev !== team.id) await clearDownstream(conf, "CONF");
              await upsertPick(g.id, team.id);
            } catch (e) {
              toast(e.message || "Error guardando pick");
            }
          }
        }));
      }

      return col;
    }

    function superBowlColumn() {
      const col = el("div", { class:"card" }, [
        el("h2", {}, "Super Bowl"),
      ]);

      const g = sbGame();
      if (!g) {
        col.appendChild(el("p", { class:"pill bad" }, "No hay juego SB cargado."));
        return col;
      }

      const locked = isLocked(g.kickoff_at);
      const afcW = conferenceWinner("AFC");
      const nfcW = conferenceWinner("NFC");

      if (!afcW || !nfcW) {
        col.appendChild(el("p", { class:"muted small" }, "Primero elige campeones de conferencia (AFC y NFC) para definir el Super Bowl."));
        return col;
      }

      col.appendChild(matchCard({
        title: "SB",
        kickoffAt: g.kickoff_at,
        teamA: afcW,
        teamB: nfcW,
        selectedTeamId: state.picksByGame[g.id] || null,
        locked,
        onPick: async (team) => {
          if (!state.entry) return toast("Primero crea tu entrada.");
          try {
            await upsertPick(g.id, team.id);
          } catch (e) {
            toast(e.message || "Error guardando pick");
          }
        }
      }));

      col.appendChild(el("div", { class:"divider" }));
      col.appendChild(el("p", { class:"small muted" }, "Tip anti-copia: puedes ocultar picks de otros hasta que cierre cada ronda usando RLS."));

      return col;
    }

    function playView() {
      if (!state.currentPool) return el("div", { class:"card" }, "No hay pool abierto.");

      const missingSeeds =
        !state.seeds ||
        Object.keys(state.seeds.AFC || {}).length < 7 ||
        Object.keys(state.seeds.NFC || {}).length < 7;

      const wcCount = state.games.filter(g => g.round === "WC").length;
      const divCount = state.games.filter(g => g.round === "DIV").length;
      const confCount = state.games.filter(g => g.round === "CONF").length;
      const sbCount = state.games.filter(g => g.round === "SB").length;

      const statusCard = el("div", { class:"card" }, [
        el("h2", {}, "Estado del bracket"),
        el("p", {}, [
          el("span", {}, "Pool: "),
          el("strong", {}, state.currentPool.name),
          el("span", { class:"muted small" }, ` · id: ${state.currentPool.id}`)
        ]),
        missingSeeds
          ? el("p", { class:"pill bad" }, "Faltan seeds (1..7 AFC/NFC). El admin debe cargarlos.")
          : el("p", { class:"pill ok" }, "Seeds OK (AFC/NFC)."),
        (wcCount===6 && divCount===4 && confCount===2 && sbCount===1)
          ? el("p", { class:"pill ok" }, "Juegos OK (13/13).")
          : el("p", { class:"pill bad" }, `Juegos incompletos: WC=${wcCount}, DIV=${divCount}, CONF=${confCount}, SB=${sbCount}.`),
        el("p", { class:"muted small" }, "Si algo está en rojo, ve a Admin y carga lo faltante en Supabase.")
      ]);

      const bracket = el("div", { class:"colsBracket" }, [
        bracketColumn("AFC", "WC"),
        bracketColumn("AFC", "DIV"),
        bracketColumn("AFC", "CONF"),
        el("div", { class:"card" }, [
          el("h2", {}, "NFC — Wild Card"),
          el("p", { class:"muted small" }, "Desplázate: abajo están Divisional/Conference NFC y el Super Bowl."),
        ]),
      ]);

      const bracket2 = el("div", { class:"colsBracket" }, [
        bracketColumn("NFC", "WC"),
        bracketColumn("NFC", "DIV"),
        bracketColumn("NFC", "CONF"),
        superBowlColumn(),
      ]);

      return el("div", { class:"grid cols-2" }, [
        statusCard,
        entryCard(),
        el("div", { class:"card", style:"grid-column: 1 / -1;" }, [
          el("h2", {}, "Bracket"),
          el("p", { class:"muted small" }, "El sistema calcula reseeding en Divisional según tus ganadores de Wild Card."),
          el("div", { class:"divider" }),
          bracket,
          el("div", { class:"divider" }),
          bracket2,
        ])
      ]);
    }

    function appShell() {
      const app = el("div", {}, [
        nav(),
        state.view === "pools" ? poolsView()
          : state.view === "admin" ? adminView()
          : playView()
      ]);
      return app;
    }

    /***********************************************************************
     * OPEN POOL
     **********************************************************************/
    async function openPool(poolId) {
      const p = state.pools.find(x => x.id === poolId);
      if (!p) return toast("Pool no encontrado.");
      state.currentPool = p;

      await loadSeedsAndTeams();
      await loadGames();
      await loadEntry(poolId);
      await loadPicks(state.entry?.id);

      state.view = "play";
      toast("Pool abierto.");
      render();
    }

    /***********************************************************************
     * INIT + RENDER LOOP
     **********************************************************************/
    async function refreshAll() {
      state.user = await getUser();
      renderUserBox();

      if (!state.user) return;

      await loadPools();

      // if there is a currentPool, refresh its data too
      if (state.currentPool) {
        await loadSeedsAndTeams();
        await loadGames();
        await loadEntry(state.currentPool.id);
        await loadPicks(state.entry?.id);

        // refresh pool object from server (admin_user_id etc)
        const { data, error } = await supabase.from("pools").select("*").eq("id", state.currentPool.id).single();
        if (!error) state.currentPool = data;
      }
    }

    function render() {
      renderUserBox();
      const root = $("#app");
      root.innerHTML = "";

      if (!state.user) {
        root.appendChild(loginView());
        return;
      }

      root.appendChild(appShell());
    }

    async function init() {
      // Auth changes
      supabase.auth.onAuthStateChange(async (_event, session) => {
        state.user = session?.user || null;
        if (!state.user) {
          state.view = "pools";
          state.currentPool = null;
          state.entry = null;
          state.picksByGame = {};
        }
        await refreshAll();
        render();
      });

      await refreshAll();
      render();
    }

    init().catch(e => {
      console.error(e);
      toast(e.message || "Error inicializando");
    });
  </script>
</body>
</html>
